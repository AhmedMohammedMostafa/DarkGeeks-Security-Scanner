const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const winston = require("winston");

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [new winston.transports.File({ filename: "logs/malware.log" })],
});

class MalwareDetector {
  constructor() {
    this.knownMalwareSignatures = {
      ransomware: [/\.wannacry$/i, /\.locky$/i, /\.cryptolocker$/i],
      trojans: [/backdoor/i, /trojan/i, /rootkit/i],
      suspicious_patterns: [
        /powershell -encodedcommand/i,
        /cmd.exe.*\/c/i,
        /rundll32.*javascript/i,
      ],
    };

    this.suspiciousBehaviors = [
      {
        pattern: /net user.*\/add/i,
        description: "Attempting to create new user",
      },
      {
        pattern: /net localgroup.*administrators.*\/add/i,
        description: "Attempting to add user to admin group",
      },
      { pattern: /reg.*delete/i, description: "Attempting to modify registry" },
    ];
  }

  async scanFile(filePath) {
    try {
      const fileContent = await fs.promises.readFile(filePath);
      const fileHash = crypto
        .createHash("sha256")
        .update(fileContent)
        .digest("hex");
      const fileName = path.basename(filePath);
      const threats = [];

      // Check file signatures
      for (const [category, patterns] of Object.entries(
        this.knownMalwareSignatures
      )) {
        for (const pattern of patterns) {
          if (pattern.test(fileName) || pattern.test(fileContent.toString())) {
            threats.push({
              type: category,
              pattern: pattern.toString(),
              location: filePath,
            });
          }
        }
      }

      // Check for suspicious behaviors in text files
      if (this.isTextFile(filePath)) {
        const content = fileContent.toString();
        for (const behavior of this.suspiciousBehaviors) {
          if (behavior.pattern.test(content)) {
            threats.push({
              type: "suspicious_behavior",
              description: behavior.description,
              location: filePath,
            });
          }
        }
      }

      const scanResult = {
        filePath,
        fileHash,
        timestamp: new Date().toISOString(),
        threats,
        isClean: threats.length === 0,
      };

      logger.info({
        message: "File scan completed",
        result: scanResult,
      });

      return scanResult;
    } catch (error) {
      logger.error({
        message: "File scan failed",
        error: error.message,
        filePath,
      });
      throw error;
    }
  }

  async scanDirectory(dirPath, options = { recursive: true }) {
    try {
      const results = [];
      const files = await this.getFiles(dirPath, options.recursive);

      for (const file of files) {
        try {
          const result = await this.scanFile(file);
          results.push(result);
        } catch (error) {
          logger.error(`Error scanning file ${file}: ${error.message}`);
          results.push({
            filePath: file,
            error: error.message,
            timestamp: new Date().toISOString(),
          });
        }
      }

      return {
        directoryPath: dirPath,
        timestamp: new Date().toISOString(),
        totalFiles: results.length,
        threatsFound: results.filter((r) => !r.isClean).length,
        results,
      };
    } catch (error) {
      logger.error(`Directory scan failed: ${error.message}`);
      throw error;
    }
  }

  async getFiles(dirPath, recursive) {
    const files = [];
    const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      if (entry.isDirectory() && recursive) {
        files.push(...(await this.getFiles(fullPath, recursive)));
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }

    return files;
  }

  isTextFile(filePath) {
    const textExtensions = [
      ".txt",
      ".js",
      ".py",
      ".sh",
      ".bat",
      ".ps1",
      ".vbs",
    ];
    return textExtensions.includes(path.extname(filePath).toLowerCase());
  }

  // Method to check for abnormal system behavior
  async checkSystemBehavior() {
    // This would integrate with system monitoring tools
    // For now, return a mock response
    return {
      timestamp: new Date().toISOString(),
      systemChecks: {
        unusualProcesses: false,
        suspiciousConnections: false,
        resourceSpikes: false,
      },
      status: "normal",
    };
  }
}

module.exports = new MalwareDetector();
